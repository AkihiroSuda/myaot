package compile

import (
	"bytes"
	"debug/elf"
	_ "embed"
	"encoding/binary"
	"errors"
	"fmt"
	"io"

	"github.com/AkihiroSuda/myaot/pkg/iomisc"
	"github.com/AkihiroSuda/myaot/pkg/signext"
	"github.com/sirupsen/logrus"
	"gitlab.com/knipegp/vemu/decoder"
)

//go:embed rt_c
var rtC []byte

func Compile(w io.Writer, r io.ReaderAt) error {
	w = iomisc.ForceWriter(w) // For code readability

	f, err := elf.NewFile(r)
	if err != nil {
		return err
	}
	defer f.Close()

	logrus.Debugf("ELF: %+v", f.FileHeader)
	if f.ByteOrder != binary.LittleEndian {
		return fmt.Errorf("expected ByteOrder=LittleEndian, got %v", f.ByteOrder)
	}
	if f.Type != elf.ET_EXEC {
		return fmt.Errorf("expected Type=ET_EXEC, got %v", f.Type)
	}
	if f.Machine != elf.EM_RISCV {
		return fmt.Errorf("expected Machine=EM_RISCV, got %v", f.Machine)
	}

	var textSec *elf.Section
	for i, sec := range f.Sections {
		i, sec := i, sec
		logrus.Debugf("ELF: Section %d: %+v", i, sec.SectionHeader)
		switch sec.SectionHeader.Type {
		case elf.SHT_PROGBITS:
			switch sec.Name {
			case ".text":
				if textSec != nil {
					return errors.New("multiple .text sections were found")
				}
				textSec = sec
			}
		}
	}

	if textSec == nil {
		return errors.New("loader: no .text section was found")
	}
	logrus.Debugf("ELF: Text size=%d, begins at 0x%08X", textSec.Size, textSec.Addr)

	// Set constants
	fmt.Fprintln(w, "/* Generated by MyAOT */")
	if logrus.GetLevel() >= logrus.DebugLevel {
		fmt.Fprintln(w, "#define _MA_DEBUG")
	}
	switch f.Class {
	case elf.ELFCLASS32:
		fmt.Fprintln(w, "#define _MA_REG_TYPE uint32_t")
	case elf.ELFCLASS64:
		logrus.Warn("ELFCLASS64 is not properly supported yet")
		fmt.Fprintln(w, "#define _MA_REG_TYPE uint64_t")
	default:
		return fmt.Errorf("unknown ELF class %v", f.Class)
	}
	fmt.Fprintln(w, "")

	// Copy rt_c
	io.Copy(w, bytes.NewReader(rtC))
	fmt.Fprintln(w, "")

	// Generate AT_PHDR
	if err = generatePH(w, r, f); err != nil {
		return err
	}

	// Generate VMA entries
	vmaEntryIdx := 0
	for _, sec := range f.Sections {
		if sec.Addr == 0 {
			continue
		}
		var hasBytes bool
		switch {
		case sec.Name == ".text", sec.Type == elf.SHT_NOBITS:
			// NOP
		default:
			hasBytes = true
			dat, err := sec.Data()
			if err != nil {
				return err
			}
			fmt.Fprintf(w, "uint8_t _ma_vma_entry_%d_bytes[] = {\n", vmaEntryIdx)
			for i, b := range dat {
				fmt.Fprintf(w, "0x%02X, ", b)
				if i%16 == 15 {
					fmt.Fprintln(w, "")
				}
			}
			fmt.Fprintf(w, "}; /* _ma_vma_entry_%d_bytes */\n", vmaEntryIdx)
		}
		fmt.Fprintf(w, "/* %+v */\n", sec.SectionHeader)
		fmt.Fprintf(w, "struct _ma_vma_entry _ma_vma_entry_%d = {\n", vmaEntryIdx)
		fmt.Fprintf(w, ".addr = %d,\n", sec.Addr)
		fmt.Fprintf(w, ".len = %d,\n", sec.Size)
		if hasBytes {
			fmt.Fprintf(w, ".bytes = _ma_vma_entry_%d_bytes,\n", vmaEntryIdx)
		}
		fmt.Fprintf(w, "}; /* _ma_vma_entry_%d */\n", vmaEntryIdx)
		fmt.Fprintln(w, "")
		vmaEntryIdx++
	}
	fmt.Fprintln(w, "")

	// Generate heap VMA entry
	fmt.Fprintln(w, "/* HEAP */")
	fmt.Fprintf(w, "struct _ma_vma_entry _ma_vma_entry_%d = {\n", vmaEntryIdx)
	fmt.Fprintln(w, "/* Fulfilled in _ma_vma_heap_entry_init() */")
	fmt.Fprintf(w, "}; /* _ma_vma_entry_%d */\n", vmaEntryIdx)
	fmt.Fprintln(w, "")
	fmt.Fprintf(w, "struct _ma_vma_entry *_ma_vma_heap_entry = &_ma_vma_entry_%d;\n", vmaEntryIdx)
	fmt.Fprintln(w, "")
	vmaEntryIdx++

	// Generate stack VMA entry
	fmt.Fprintln(w, "/* STACK */")
	fmt.Fprintf(w, "struct _ma_vma_entry _ma_vma_entry_%d = {\n", vmaEntryIdx)
	fmt.Fprintln(w, "/* Fulfilled in _ma_vma_stack_entry_init() */")
	fmt.Fprintf(w, "}; /* _ma_vma_entry_%d */\n", vmaEntryIdx)
	fmt.Fprintln(w, "")
	fmt.Fprintf(w, "struct _ma_vma_entry *_ma_vma_stack_entry = &_ma_vma_entry_%d;\n", vmaEntryIdx)
	fmt.Fprintln(w, "")
	vmaEntryIdx++

	// Generate VMA table in the descending order,
	// to support overwrapping https://stackoverflow.com/questions/25501044/gcc-ld-overlapping-sections-tbss-init-array-in-statically-linked-elf-bin
	fmt.Fprintln(w, "struct _ma_vma_entry *_ma_vma_entries[] = {")
	for i := vmaEntryIdx - 1; i >= 0; i-- {
		fmt.Fprintf(w, "&_ma_vma_entry_%d,\n", i)
	}
	fmt.Fprintln(w, "NULL,")
	fmt.Fprintln(w, "}; /* _ma_vma_entries */")
	fmt.Fprintln(w, "")

	// Generate the main state machine
	if err = generateMain(w, f, textSec); err != nil {
		return err
	}

	return nil
}

func generatePH(w io.Writer, r io.ReaderAt, elfFile *elf.File) error {
	sr := io.NewSectionReader(r, 0, 1<<63-1)
	if _, err := sr.Seek(0, io.SeekStart); err != nil {
		return err
	}
	var (
		phent, phnum int
		phoff        int64
	)
	switch elfFile.Class {
	case elf.ELFCLASS32:
		var hdr elf.Header32
		if err := binary.Read(sr, elfFile.ByteOrder, &hdr); err != nil {
			return err
		}
		phent, phnum, phoff = int(hdr.Phentsize), int(hdr.Phnum), int64(hdr.Phoff)
	case elf.ELFCLASS64:
		var hdr elf.Header64
		if err := binary.Read(sr, elfFile.ByteOrder, &hdr); err != nil {
			return err
		}
		phent, phnum, phoff = int(hdr.Phentsize), int(hdr.Phnum), int64(hdr.Phoff)
	default:
		return fmt.Errorf("unsupported ELF class %+v", elfFile.Class)
	}
	fmt.Fprintf(w, "_ma_reg_t _ma_at_phent=%d;\n", phent)
	fmt.Fprintf(w, "_ma_reg_t _ma_at_phnum=%d;\n", phnum)
	fmt.Fprintf(w, "_ma_reg_t _ma_at_entry=%d;\n", elfFile.Entry)
	fmt.Fprintln(w, "uint8_t _ma_at_ph[] = {")
	phSz := phent * phnum
	ph := make([]byte, phSz)
	n, err := r.ReadAt(ph, phoff)
	if err != nil {
		return err
	}
	if n != phSz {
		return errors.New("partial PH")
	}
	for i, b := range ph {
		fmt.Fprintf(w, "0x%02X, ", b)
		if i%16 == 15 {
			fmt.Fprintln(w, "")
		}
	}
	fmt.Fprintln(w, "}; /* _ma_at_ph */")
	fmt.Fprintln(w, "")
	return nil
}

// TODO: support non-32 bit instructions
func generateMain(w io.Writer, elfFile *elf.File, textSec *elf.Section) error {
	fmt.Fprintln(w, "typedef _ma_reg_t (*_ma_code_func_t)(_ma_reg_t pc);")
	fmt.Fprintln(w, "")

	// The instructions are split to small "segments" to shorten the compilation time
	const segSize uint64 = 1024
	fmt.Fprintln(w, "/* Macros */")
	fmt.Fprintln(w, "#define _MA_GOTO_ADDR_NEAR(addr, seg_head) goto *addr_labels[((addr) - (seg_head))/4]")
	fmt.Fprintln(w, "#define _MA_GOTO_ADDR_FAR(addr) return (addr)")
	fmt.Fprintf(w, "#define _MA_GOTO_ADDR(addr, seg_head) if (((addr) - (seg_head)) < %d) { _MA_GOTO_ADDR_NEAR((addr), (seg_head)); } else { _MA_GOTO_ADDR_FAR((addr)); }\n", segSize)
	fmt.Fprintln(w, "#define _MA_GOTO_MODIFIED_PC(pc_modified, seg_head) {_ma_reg_t pc_modified_bak = (pc_modified); (pc_modified) = 0; _MA_GOTO_ADDR(pc_modified_bak, (seg_head));}")
	fmt.Fprintln(w, "")

	textReader := textSec.Open()
	for instAddr := textSec.Addr; instAddr < textSec.Addr+textSec.Size; instAddr += segSize {
		currentSegSize := segSize
		if instAddr+currentSegSize > textSec.Addr+textSec.Size {
			currentSegSize = textSec.Addr + textSec.Size - instAddr
		}
		if err := generateCodeFunc(w, textReader, instAddr, currentSegSize); err != nil {
			return fmt.Errorf("failed to generate the function (segmentation addr=0x%08X, size=%d): %w", instAddr, currentSegSize, err)
		}
	}

	fmt.Fprintln(w, "_ma_code_func_t _ma_code_funcs[] = {")
	for instAddr := textSec.Addr; instAddr < textSec.Addr+textSec.Size; instAddr += segSize {
		fmt.Fprintf(w, "&_ma_code_func_0x%08X,\n", instAddr)
	}
	fmt.Fprintln(w, "}; /* _ma_code_funcs */")
	fmt.Fprintln(w, "")

	fmt.Fprintln(w, "int main(int argc, char *argv[]) {")
	fmt.Fprintln(w, "/* Init */")
	fmt.Fprintln(w, "_ma_vma_heap_entry_init();")
	fmt.Fprintln(w, "_ma_vma_stack_entry_init(argc, argv);")
	fmt.Fprintf(w, "_ma_reg_t pc = 0x%08X;\n", elfFile.Entry)
	fmt.Fprintln(w, "while(1) {")
	fmt.Fprintf(w, "int f_idx = (pc - 0x%08X) / %d;\n", textSec.Addr, segSize)
	fmt.Fprintln(w, "_ma_code_func_t f = _ma_code_funcs[f_idx];")
	fmt.Fprintln(w, "pc = f(pc);")
	fmt.Fprintln(w, "} /* while(1) */")
	fmt.Fprintln(w, "} /* main */")
	fmt.Fprintln(w, "")

	return nil
}

func generateReadRegExpr(reg decoder.RegisterIndex) string {
	if reg == 0 {
		// Hard-wired zero
		return "0"
	}
	return fmt.Sprintf("_ma_regs.x[%d]", reg)
}

func generateCodeFunc(w io.Writer, r io.Reader, segHead, segSize uint64) error {
	fmt.Fprintf(w, "_ma_reg_t _ma_code_func_0x%08X(_ma_reg_t pc_initial){\n", segHead)
	fmt.Fprintln(w, "const void *addr_labels[] = {")
	for instAddr := segHead; instAddr < segHead+segSize; instAddr += 4 {
		fmt.Fprintf(w, "&&L_0x%08X,\n", instAddr)
	}
	fmt.Fprintln(w, "}; /* addr_labels */")
	fmt.Fprintln(w, "/* Temp variables */")
	fmt.Fprintln(w, "uint8_t u8;")
	fmt.Fprintln(w, "uint16_t u16;")
	fmt.Fprintln(w, "uint32_t u32, u32_x, u32_y;")
	fmt.Fprintln(w, "void *p;")
	fmt.Fprintln(w, "/* Program counter (only set if it was modified)*/")
	fmt.Fprintln(w, "_ma_reg_t pc_modified = 0;")
	fmt.Fprintf(w, "_MA_GOTO_ADDR_NEAR(pc_initial, 0x%08X)\n;", segHead)

	for instAddr := segHead; instAddr < segHead+segSize; instAddr += 4 {
		var inst32 uint32
		if err := binary.Read(r, binary.LittleEndian, &inst32); err != nil {
			return err
		}
		if err := generateCodeEntry(w, segHead, instAddr, inst32); err != nil {
			return fmt.Errorf("%w (addr=0x%08X, instruction=0x%08X)", err, instAddr, inst32)
		}
	}

	fmt.Fprintf(w, "return 0x%08X\n;", segHead+segSize)
	fmt.Fprintf(w, "} /* _ma_code_func_0x%08X */\n", segHead)
	fmt.Fprintln(w, "")
	return nil
}

type PCStatus int

const (
	PCStatusSurelyUnmodified PCStatus = iota
	PCStatusSurelyModified
	PCStatusMaybeModified
)

func generateCodeEntry(w io.Writer, segHead, instAddr uint64, inst32 uint32) error {
	fmt.Fprintf(w, "L_0x%08X:\n", instAddr)
	if logrus.GetLevel() >= logrus.DebugLevel {
		fmt.Fprintf(w, "_ma_regs_dump(0x%08X);\n", instAddr)
	}
	inst := decoder.NewRawInstruction(inst32)
	pcStatus := PCStatusSurelyUnmodified
	switch inst.MajOp {
	case decoder.Std:
		switch minorOp := inst.GetMinorOpcode(); minorOp {
		case decoder.IntRegReg:
			rd, rs1, rs2 := inst.GetRd(), inst.GetRs1(), inst.GetRs2()
			if rd == 0 {
				break
			}
			switch f3 := inst.GetFunct3(); f3 {
			case decoder.RegDiff:
				switch f7 := inst.GetFunct7(); f7 {
				case decoder.Add: // add rd,rs1,rs2: x[rd] = x[rs1] + x[rs2]
					fmt.Fprintf(w, "_ma_regs.x[%d] = %s + %s;\n", rd, generateReadRegExpr(rs1), generateReadRegExpr(rs2))
				case decoder.Sub: // sub rd,rs1,rs2: x[rd] = x[rs1] - x[rs2]
					fmt.Fprintf(w, "_ma_regs.x[%d] = %s - %s;\n", rd, generateReadRegExpr(rs1), generateReadRegExpr(rs2))
				default:
					return fmt.Errorf("unsupported RegReg funct7 %+v", f7)
				}
			case decoder.Sll: // sll rd,rs1,rs2: x[rd] = x[rs1] << x[rs2]
				fmt.Fprintf(w, "_ma_regs.x[%d] = %s << %s;\n", rd, generateReadRegExpr(rs1), generateReadRegExpr(rs2))
			case decoder.Slt: // slt rd,rs1,rs2: x[rd] = x[rs1] <s x[rs2]:
				fmt.Fprintf(w, "_ma_regs.x[%d] = (signed)%s < (signed)%s;\n", rd, generateReadRegExpr(rs1), generateReadRegExpr(rs2))
			case decoder.Sltu: // sltu rd,rs1,rs2: x[rd] = x[rs1] <u x[rs2]:
				fmt.Fprintf(w, "_ma_regs.x[%d] = %s < %s;\n", rd, generateReadRegExpr(rs1), generateReadRegExpr(rs2))
			case decoder.Xor: // xor rd,rs1,rs2: x[rd] = x[rs1] ^ x[rs2]
				fmt.Fprintf(w, "_ma_regs.x[%d] = %s ^ %s;\n", rd, generateReadRegExpr(rs1), generateReadRegExpr(rs2))
			case decoder.RegShift:
				switch f7 := inst.GetFunct7(); f7 {
				case decoder.Srl: // srl rd,rs1,rs2: x[rd] = x[rs1] >>u x[rs2]
					fmt.Fprintf(w, "_ma_regs.x[%d] = ((unsigned)%s >> %s & 0x1f);\n", rd, generateReadRegExpr(rs1), generateReadRegExpr(rs2))
				case decoder.Sra: // sra rd,rs1,rs2: x[rd] = x[rs1] >>s x[rs2]
					fmt.Fprintf(w, "_ma_regs.x[%d] = ((signed)%s >> %s & 0x1f);\n", rd, generateReadRegExpr(rs1), generateReadRegExpr(rs2))
				default:
					return fmt.Errorf("unsupported RegReg funct7 %+v", f7)
				}
			case decoder.Or: // or rd,rs1,rs2: x[rd] = x[rs1] | x[rs2]
				fmt.Fprintf(w, "_ma_regs.x[%d] = %s | %s;\n", rd, generateReadRegExpr(rs1), generateReadRegExpr(rs2))
			case decoder.And: // and rd,rs1,rs2: x[rd] = x[rs1] & x[rs2]
				fmt.Fprintf(w, "_ma_regs.x[%d] = %s & %s;\n", rd, generateReadRegExpr(rs1), generateReadRegExpr(rs2))
			default:
				return fmt.Errorf("unsupported RegReg funct3 %+v", f3)
			}
		case decoder.IntRegImm:
			rd, rs1, imm := inst.GetRd(), inst.GetRs1(), inst.GetImmediate()
			if rd == 0 {
				break
			}
			shamt := imm & 0b11111
			switch f3 := inst.GetFunct3(); f3 {
			case decoder.Addi: // addi rd,rs1,imm: x[rd] = x[rs1] + sext(immediate)
				fmt.Fprintf(w, "_ma_regs.x[%d] = %s + (signed)%d;\n", rd, generateReadRegExpr(rs1), signext.SignExt(int(imm), 12))
			case decoder.Slli: // slli rd,rs1,shamt: x[rd] = x[rs1] << shamt
				fmt.Fprintf(w, "_ma_regs.x[%d] = %s << %d;\n", rd, generateReadRegExpr(rs1), shamt)
			case decoder.Sr:
				switch f7 := inst.GetFunct7(); f7 {
				case decoder.Srl: // srli rd,rs1,shamt: x[rd] = x[rs1] >>u shamt // logical shift
					fmt.Fprintf(w, "_ma_regs.x[%d] = ((unsigned)%s >> %d);\n", rd, generateReadRegExpr(rs1), shamt)
				case decoder.Sra: // srai rd,rs1,shamt: x[rd] = x[rs1] >>s shamt // arithmetic shift
					fmt.Fprintf(w, "_ma_regs.x[%d] = ((signed)%s >> %d);\n", rd, generateReadRegExpr(rs1), shamt)
				default:
					return fmt.Errorf("unsupported IntRegImm funct7 %+v", f7)
				}
			case decoder.Slti: // slti rd,rs1,imm: x[rd] = x[rs1] <s sext(immediate)
				fmt.Fprintf(w, "_ma_regs.x[%d] = (signed)%s < (signed)%d;\n", rd, generateReadRegExpr(rs1), signext.SignExt(int(imm), 12))
			case decoder.Sltiu: // sltiu rd,rs1,imm: x[rd] = x[rs1] <u sext(immediate)
				fmt.Fprintf(w, "_ma_regs.x[%d] = (unsigned) %s < (unsigned)%d;\n", rd, generateReadRegExpr(rs1), signext.SignExt(int(imm), 12))
			case decoder.Andi: // andi rd,rs1,imm: x[rd] = x[rs1] & sext(immediate)
				fmt.Fprintf(w, "_ma_regs.x[%d] = %s & (signed)%d;\n", rd, generateReadRegExpr(rs1), signext.SignExt(int(imm), 12))
			case decoder.Xori: // xori rd,rs1,imm: x[rd] = x[rs1] ^ sext(immediate)
				fmt.Fprintf(w, "_ma_regs.x[%d] = %s ^ (signed)%d;\n", rd, generateReadRegExpr(rs1), signext.SignExt(int(imm), 12))
			case decoder.Ori: // ori rd,rs1,imm: x[rd] = x[rs1] | sext(immediate)
				fmt.Fprintf(w, "_ma_regs.x[%d] = %s | (signed)%d;\n", rd, generateReadRegExpr(rs1), signext.SignExt(int(imm), 12))
			default:
				return fmt.Errorf("unsupported IntRegImm funct3 %+v", f3)
			}
		case decoder.Load:
			rd, rs1, imm := inst.GetRd(), inst.GetRs1(), inst.GetImmediate()
			if rd == 0 {
				break
			}
			fmt.Fprintf(w, "p = _ma_translate_ptr(%s + (signed)%d);\n", generateReadRegExpr(rs1), signext.SignExt(int(imm), 12))
			switch f3 := inst.GetFunct3(); f3 {
			case decoder.Lb: // lb rd,offset(rs1): x[rd] = sext(M[x[rs1] + sext(offset)][7:0])
				fmt.Fprintln(w, "u8 = *(uint8_t*)p;")
				fmt.Fprintf(w, "_ma_regs.x[%d] = (signed)_MA_SIGN_EXT((_ma_reg_t)u8, 8);\n", rd)
			case decoder.Lbu: // lbu rd,offset(rs1): x[rd] = M[x[rs1] + sext(offset)][7:0]
				fmt.Fprintln(w, "u8 = *(uint8_t*)p;")
				fmt.Fprintf(w, "_ma_regs.x[%d] = u8;\n", rd)
			case decoder.Lh: // lh rd,offset(rs1): x[rd] = sext(M[x[rs1] + sext(offset)][15:0])
				fmt.Fprintln(w, "u16 = *(uint16_t*)p;")
				fmt.Fprintf(w, "_ma_regs.x[%d] = (signed)_MA_SIGN_EXT((_ma_reg_t)u16, 16);\n", rd)
			case decoder.Lhu: // lhu rd,offset(rs1): x[rd] = M[x[rs1] + sext(offset)][15:0]
				fmt.Fprintln(w, "u16 = *(uint16_t*)p;")
				fmt.Fprintf(w, "_ma_regs.x[%d] = u16;\n", rd)
			case decoder.Lw: // lw rd,offset(rs1): x[rd] = sext(M[x[rs1] + sext(offset)][31:0])
				fmt.Fprintln(w, "u32 = *(uint32_t*)p;")
				fmt.Fprintf(w, "_ma_regs.x[%d] = (signed)_MA_SIGN_EXT((_ma_reg_t)u32, 32);\n", rd)
			default:
				return fmt.Errorf("unsupported Load funct3 %+v", f3)
			}
		case decoder.Store:
			rs1, rs2, imm := inst.GetRs1(), inst.GetRs2(), inst.GetImmediate()
			fmt.Fprintf(w, "p = _ma_translate_ptr(%s + (signed)%d);\n", generateReadRegExpr(rs1), signext.SignExt(int(imm), 12))
			switch f3 := inst.GetFunct3(); f3 {
			case decoder.Sb: // sb rs2,offset(rs1): M[x[rs1] + sext(offset)] = x[rs2][7:0]]
				fmt.Fprintf(w, "u8 = %s & 0xFF;\n", generateReadRegExpr(rs2))
				fmt.Fprintln(w, "*(uint8_t*)p = u8;")
			case decoder.Sh: // sh rs2,offset(rs1): M[x[rs1] + sext(offset)] = x[rs2][15:0]]
				fmt.Fprintf(w, "u16 = %s & 0xFFFF;\n", generateReadRegExpr(rs2))
				fmt.Fprintln(w, "*(uint16_t*)p = u16;")
			case decoder.Sw: // sw rs2,offset(rs1): M[x[rs1] + sext(offset)] = x[rs2][31:0]]
				fmt.Fprintf(w, "u32 = %s & 0xFFFFFFFF;\n", generateReadRegExpr(rs2))
				fmt.Fprintln(w, "*(uint32_t*)p = u32;")
			default:
				return fmt.Errorf("unsupported Store funct3 %+v", f3)
			}
		case decoder.Branch:
			rs1, rs2, imm := inst.GetRs1(), inst.GetRs2(), inst.GetImmediate()
			switch f3 := inst.GetFunct3(); f3 {
			case decoder.Beq: // beq rs1,rs2,offset: if (x[rs1] == x[rs2]) pc += sext(offset)
				fmt.Fprintf(w, "if (%s == %s) { pc_modified = 0x%08X; }\n", generateReadRegExpr(rs1), generateReadRegExpr(rs2), instAddr+uint64(signext.SignExt(int(imm), 13)))
			case decoder.Bne: // bne rs1,rs2,offset: if (x[rs1] != x[rs2]) pc += sext(offset)
				fmt.Fprintf(w, "if (%s != %s) { pc_modified = 0x%08X; }\n", generateReadRegExpr(rs1), generateReadRegExpr(rs2), instAddr+uint64(signext.SignExt(int(imm), 13)))
			case decoder.Blt: // blt rs1,rs2,offset: if (x[rs1] <s x[rs2]) pc += sext(offset) // signed
				fmt.Fprintf(w, "if ((signed)%s < (signed)%s) { pc_modified = 0x%08X; }\n", generateReadRegExpr(rs1), generateReadRegExpr(rs2), instAddr+uint64(signext.SignExt(int(imm), 13)))
			case decoder.Bltu: // bltu rs1,rs2,offset: if (x[rs1] <u x[rs2]) pc += sext(offset) // unsigned
				fmt.Fprintf(w, "if (%s < %s) { pc_modified = 0x%08X; }\n", generateReadRegExpr(rs1), generateReadRegExpr(rs2), instAddr+uint64(signext.SignExt(int(imm), 13)))
			case decoder.Bge: // bge rs1,rs2,offset: if (x[rs1] >=s x[rs2]) pc += sext(offset) // signed
				fmt.Fprintf(w, "if ((signed)%s >= (signed)%s) { pc_modified = 0x%08X; }\n", generateReadRegExpr(rs1), generateReadRegExpr(rs2), instAddr+uint64(signext.SignExt(int(imm), 13)))
			case decoder.Bgeu: // bgeu rs1,rs2,offset: if (x[rs1] >=u x[rs2]) pc += sext(offset) // unsigned
				fmt.Fprintf(w, "if (%s >= %s) { pc_modified = 0x%08X; }\n", generateReadRegExpr(rs1), generateReadRegExpr(rs2), instAddr+uint64(signext.SignExt(int(imm), 13)))
			default:
				return fmt.Errorf("unsupported Branch funct3 %+v", f3)
			}
			pcStatus = PCStatusMaybeModified
		case decoder.Lui: // lui rd,imm: x[rd] = sext(immediate[31:12] << 12)
			rd, imm := inst.GetRd(), inst.GetImmediate()
			if rd == 0 {
				break
			}
			fmt.Fprintf(w, "_ma_regs.x[%d] = (signed)%d;\n", rd, signext.SignExt(int(imm), 32))
		case decoder.Auipc: // auipc rd,imm: x[rd] = pc + sext(immediate[31:12] << 12)
			rd, imm := inst.GetRd(), inst.GetImmediate()
			if rd == 0 {
				break
			}
			fmt.Fprintf(w, "_ma_regs.x[%d] = 0x%08X;\n", rd, instAddr+uint64(signext.SignExt(int(imm), 32)))
		case decoder.Jal: // jal rd,offset: x[rd] = pc+4; pc += sext(offset)
			rd, imm := inst.GetRd(), inst.GetImmediate()
			if rd != 0 {
				fmt.Fprintf(w, "_ma_regs.x[%d] = 0x%08X;\n", rd, instAddr+4)
			}
			fmt.Fprintf(w, "pc_modified = 0x%08X;\n", instAddr+uint64(signext.SignExt(int(imm), 21)))
			pcStatus = PCStatusSurelyModified
		case decoder.Jalr: // jalr rd,rs1,offset: t =pc+4; pc=(x[rs1]+sext(offset))&∼1; x[rd]=t
			rd, rs1, imm := inst.GetRd(), inst.GetRs1(), inst.GetImmediate()
			fmt.Fprintf(w, "pc_modified = (%s + (signed)%d)&~1;\n", generateReadRegExpr(rs1), signext.SignExt(int(imm), 12))
			if rd != 0 {
				fmt.Fprintf(w, "_ma_regs.x[%d] = 0x%08X;\n", rd, instAddr+4)
			}
			pcStatus = PCStatusSurelyModified
		case decoder.Sys:
			fmt.Fprintln(w, "_ma_ecall();")
		case decoder.FenceOp: // WIP, probably wrong
			fmt.Fprintln(w, "/* NOP */;")
		case decoder.Atomic:
			rd, rs1, rs2 := inst.GetRd(), inst.GetRs1(), inst.GetRs2() // often rd == rs2
			fmt.Fprintf(w, "p = _ma_translate_ptr(%s);\n", generateReadRegExpr(rs1))
			f5head, f5tail := decoder.Funct5Head(inst32>>29), decoder.Funct5Tail((inst32>>27)&0x3)
			switch f3 := inst.GetFunct3(); f3 {
			case decoder.Atomic32: // WIP, needs mutex
				switch f5head {
				case decoder.CommonAtomic:
					switch f5tail {
					case decoder.ArithAtomic: // amoadd.w rd,rs2,(rs1): x[rd] = AMO32(M[x[rs1]] + x[rs2])
						fmt.Fprintln(w, "u32_x = *(uint32_t*)p;")
						fmt.Fprintf(w, "u32_y = u32_x + %s\n;", generateReadRegExpr(rs2))
						if rd != 0 {
							fmt.Fprintf(w, "_ma_regs.x[%d] = u32_x;\n", rd)
						}
						fmt.Fprintln(w, "*(uint32_t*)p = u32_y;")
					case decoder.Amoswap: // amoswap.w rd,rs2,(rs1): x[rd] = AMO32(M[x[rs1]] SWAP x[rs2])
						fmt.Fprintln(w, "u32_x = *(uint32_t*)p;")
						fmt.Fprintf(w, "u32_y = %s\n;", generateReadRegExpr(rs2))
						if rd != 0 {
							fmt.Fprintf(w, "_ma_regs.x[%d] = u32_x;\n", rd)
						}
						fmt.Fprintln(w, "*(uint32_t*)p = u32_y;")
					case decoder.Lr: // lr.w rd,rs1: x[rd] = LoadReserved32(M[x[rs1]])
						if rd == 0 {
							break
						}
						fmt.Fprintln(w, "u32_x = *(uint32_t*)p;")
						fmt.Fprintf(w, "_ma_regs.x[%d] = u32_x;\n", rd)
						// TODO: implement reservation set
					case decoder.Sc: // sc.w rd,rs1,rs2: x[rd] = StoreConditional32(M[x[rs1]], x[rs2])
						fmt.Fprintf(w, "u32_y = %s;", generateReadRegExpr(rs2))
						fmt.Fprintln(w, "*(uint32_t*)p = u32_y;")
						if rd != 0 {
							fmt.Fprintf(w, "_ma_regs.x[%d] = 0;\n", rd)
						}
					default:
						return fmt.Errorf("unsupported Atomic32 CommonAtomic funct5tail %+v", f5tail)
					}
				case decoder.Amoor: // amoor.w rd,rs2,(rs1): x[rd] = AMO32(M[x[rs1]] | x[rs2])
					fmt.Fprintln(w, "u32_x = *(uint32_t*)p;")
					fmt.Fprintf(w, "u32_y = u32_x | %s\n;", generateReadRegExpr(rs2))
					if rd != 0 {
						fmt.Fprintf(w, "_ma_regs.x[%d] = u32_x;\n", rd)
					}
					fmt.Fprintln(w, "*(uint32_t*)p = u32_y;")
				case decoder.Amomaxu: // amomaxu.w rd,rs2,(rs1): x[rd] = AMO32(M[x[rs1]] MAXU x[rs2])
					fmt.Fprintln(w, "u32_x = *(uint32_t*)p;")
					fmt.Fprintf(w, "u32_y = MAX(u32_x, %s)\n;", generateReadRegExpr(rs2))
					if rd != 0 {
						fmt.Fprintf(w, "_ma_regs.x[%d] = u32_x;\n", rd)
					}
					fmt.Fprintln(w, "*(uint32_t*)p = u32_y;")
				default:
					return fmt.Errorf("unsupported Atomic32 funct5head %+v", f5head)
				}
			default:
				return fmt.Errorf("unsupported Atomic funct3 %+v", f3)
			}
		default:
			return fmt.Errorf("unsupported minor opcode 0x%02X", minorOp)
		}
	default:
		return fmt.Errorf("unsupported major opcode 0x%02X", inst.MajOp)
	}
	switch pcStatus {
	case PCStatusSurelyUnmodified:
		/* NOP */
	case PCStatusSurelyModified:
		fmt.Fprintf(w, "_MA_GOTO_MODIFIED_PC(pc_modified, 0x%08X);\n", segHead)
	case PCStatusMaybeModified:
		fmt.Fprintf(w, "if (pc_modified != 0) { _MA_GOTO_MODIFIED_PC(pc_modified, 0x%08X); }\n", segHead)
	}
	return nil
}
