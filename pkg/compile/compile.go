package compile

import (
	"bytes"
	"debug/elf"
	_ "embed"
	"encoding/binary"
	"errors"
	"fmt"
	"io"

	"github.com/AkihiroSuda/myaot/pkg/iomisc"
	"github.com/sirupsen/logrus"
	"gitlab.com/knipegp/vemu/decoder"
)

//go:embed rt_c
var rtC []byte

func Compile(w io.Writer, r io.ReaderAt) error {
	w = iomisc.ForceWriter(w) // For code readability

	f, err := elf.NewFile(r)
	if err != nil {
		return err
	}
	defer f.Close()

	logrus.Debugf("ELF: %+v", f.FileHeader)
	if f.ByteOrder != binary.LittleEndian {
		return fmt.Errorf("expected ByteOrder=LittleEndian, got %v", f.ByteOrder)
	}
	if f.Type != elf.ET_EXEC {
		return fmt.Errorf("expected Type=ET_EXEC, got %v", f.Type)
	}
	if f.Machine != elf.EM_RISCV {
		return fmt.Errorf("expected Machine=EM_RISCV, got %v", f.Machine)
	}

	var textSec *elf.Section
	for i, sec := range f.Sections {
		i, sec := i, sec
		logrus.Debugf("ELF: Section %d: %+v", i, sec.SectionHeader)
		switch sec.SectionHeader.Type {
		case elf.SHT_PROGBITS:
			switch sec.Name {
			case ".text":
				if textSec != nil {
					return errors.New("multiple .text sections were found")
				}
				textSec = sec
			}
		}
	}

	if textSec == nil {
		return errors.New("loader: no .text section was found")
	}
	logrus.Debugf("ELF: Text size=%d, begins at 0x%08X", textSec.Size, textSec.Addr)

	// Set constants
	fmt.Fprintln(w, "/* Generated by MyAOT */")
	if logrus.GetLevel() >= logrus.DebugLevel {
		fmt.Fprintln(w, "#define _MA_DEBUG")
	}
	switch f.Class {
	case elf.ELFCLASS32:
		fmt.Fprintln(w, "#define _MA_REG_TYPE uint32_t")
	case elf.ELFCLASS64:
		logrus.Warn("ELFCLASS64 is not properly supported yet")
		fmt.Fprintln(w, "#define _MA_REG_TYPE uint64_t")
	default:
		return fmt.Errorf("unknown ELF class %v", f.Class)
	}
	fmt.Fprintln(w, "")

	// Copy rt_c
	io.Copy(w, bytes.NewReader(rtC))
	fmt.Fprintln(w, "")

	// Generate AT_PHDR
	if err = generatePH(w, r, f); err != nil {
		return err
	}

	// Generate VMA entries
	vmaEntryIdx := 0
	for _, sec := range f.Sections {
		if sec.Addr == 0 {
			continue
		}
		var hasBytes bool
		switch {
		case sec.Name == ".text", sec.Type == elf.SHT_NOBITS:
			// NOP
		default:
			hasBytes = true
			dat, err := sec.Data()
			if err != nil {
				return err
			}
			fmt.Fprintf(w, "uint8_t _ma_vma_entry_%d_bytes[] = {\n", vmaEntryIdx)
			for i, b := range dat {
				fmt.Fprintf(w, "0x%02X, ", b)
				if i%16 == 15 {
					fmt.Fprintln(w, "")
				}
			}
			fmt.Fprintf(w, "}; /* _ma_vma_entry_%d_bytes */\n", vmaEntryIdx)
		}
		fmt.Fprintf(w, "/* %+v */\n", sec.SectionHeader)
		fmt.Fprintf(w, "struct _ma_vma_entry _ma_vma_entry_%d = {\n", vmaEntryIdx)
		fmt.Fprintf(w, ".addr = %d,\n", sec.Addr)
		fmt.Fprintf(w, ".len = %d,\n", sec.Size)
		if hasBytes {
			fmt.Fprintf(w, ".bytes = _ma_vma_entry_%d_bytes,\n", vmaEntryIdx)
		}
		fmt.Fprintf(w, "}; /* _ma_vma_entry_%d */\n", vmaEntryIdx)
		fmt.Fprintln(w, "")
		vmaEntryIdx++
	}
	fmt.Fprintln(w, "")

	// Generate heap VMA entry
	fmt.Fprintln(w, "/* HEAP */")
	fmt.Fprintf(w, "struct _ma_vma_entry _ma_vma_entry_%d = {\n", vmaEntryIdx)
	fmt.Fprintln(w, "/* Fulfilled in _ma_vma_heap_entry_init() */")
	fmt.Fprintf(w, "}; /* _ma_vma_entry_%d */\n", vmaEntryIdx)
	fmt.Fprintln(w, "")
	fmt.Fprintf(w, "struct _ma_vma_entry *_ma_vma_heap_entry = &_ma_vma_entry_%d;\n", vmaEntryIdx)
	fmt.Fprintln(w, "")
	vmaEntryIdx++

	// Generate stack VMA entry
	fmt.Fprintln(w, "/* STACK */")
	fmt.Fprintf(w, "struct _ma_vma_entry _ma_vma_entry_%d = {\n", vmaEntryIdx)
	fmt.Fprintln(w, "/* Fulfilled in _ma_vma_stack_entry_init() */")
	fmt.Fprintf(w, "}; /* _ma_vma_entry_%d */\n", vmaEntryIdx)
	fmt.Fprintln(w, "")
	fmt.Fprintf(w, "struct _ma_vma_entry *_ma_vma_stack_entry = &_ma_vma_entry_%d;\n", vmaEntryIdx)
	fmt.Fprintln(w, "")
	vmaEntryIdx++

	// Generate VMA table in the descending order,
	// to support overwrapping https://stackoverflow.com/questions/25501044/gcc-ld-overlapping-sections-tbss-init-array-in-statically-linked-elf-bin
	fmt.Fprintln(w, "struct _ma_vma_entry *_ma_vma_entries[] = {")
	for i := vmaEntryIdx - 1; i >= 0; i-- {
		fmt.Fprintf(w, "&_ma_vma_entry_%d,\n", i)
	}
	fmt.Fprintln(w, "NULL,")
	fmt.Fprintln(w, "}; /* _ma_vma_entries */")
	fmt.Fprintln(w, "")

	// Generate the main state machine
	if err = generateMain(w, f, textSec); err != nil {
		return err
	}

	return nil
}

func generatePH(w io.Writer, r io.ReaderAt, elfFile *elf.File) error {
	sr := io.NewSectionReader(r, 0, 1<<63-1)
	if _, err := sr.Seek(0, io.SeekStart); err != nil {
		return err
	}
	var (
		phent, phnum int
		phoff        int64
	)
	switch elfFile.Class {
	case elf.ELFCLASS32:
		var hdr elf.Header32
		if err := binary.Read(sr, elfFile.ByteOrder, &hdr); err != nil {
			return err
		}
		phent, phnum, phoff = int(hdr.Phentsize), int(hdr.Phnum), int64(hdr.Phoff)
	case elf.ELFCLASS64:
		var hdr elf.Header64
		if err := binary.Read(sr, elfFile.ByteOrder, &hdr); err != nil {
			return err
		}
		phent, phnum, phoff = int(hdr.Phentsize), int(hdr.Phnum), int64(hdr.Phoff)
	default:
		return fmt.Errorf("unsupported ELF class %+v", elfFile.Class)
	}
	fmt.Fprintf(w, "_ma_reg_t _ma_at_phent=%d;\n", phent)
	fmt.Fprintf(w, "_ma_reg_t _ma_at_phnum=%d;\n", phnum)
	fmt.Fprintf(w, "_ma_reg_t _ma_at_entry=%d;\n", elfFile.Entry)
	fmt.Fprintln(w, "uint8_t _ma_at_ph[] = {")
	phSz := phent * phnum
	ph := make([]byte, phSz)
	n, err := r.ReadAt(ph, phoff)
	if err != nil {
		return err
	}
	if n != phSz {
		return errors.New("partial PH")
	}
	for i, b := range ph {
		fmt.Fprintf(w, "0x%02X, ", b)
		if i%16 == 15 {
			fmt.Fprintln(w, "")
		}
	}
	fmt.Fprintln(w, "}; /* _ma_at_ph */")
	fmt.Fprintln(w, "")
	return nil
}

func generateMain(w io.Writer, elfFile *elf.File, textSec *elf.Section) error {
	fmt.Fprintln(w, "int main(int argc, char *argv[]) {")
	fmt.Fprintln(w, "_ma_vma_heap_entry_init();")
	fmt.Fprintln(w, "_ma_vma_stack_entry_init(argc, argv);")
	fmt.Fprintf(w, "_ma_regs.pc = 0x%08X;\n", elfFile.Entry)
	fmt.Fprintln(w, "for (;;) {")
	fmt.Fprintln(w, "_ma_regs_dump();")
	fmt.Fprintln(w, "/* TODO: use an explicit jump table (for non-WASM?) */")
	fmt.Fprintln(w, "switch(_ma_regs.pc) {")
	textReader := textSec.Open()
	var inst32 uint32
	pc := int(textSec.Addr)
	for {
		// TODO: support non-32 bit instructions
		if err := binary.Read(textReader, binary.LittleEndian, &inst32); err != nil {
			return err
		}
		fmt.Fprintf(w, "case 0x%08X: /* inst = %08X */ {\n", pc, inst32)
		inst := decoder.NewRawInstruction(inst32)
		switch inst.MajOp {
		case decoder.Std:
			switch minorOp := inst.GetMinorOpcode(); minorOp {
			case decoder.IntRegReg:
				rd, rs1, rs2 := inst.GetRd(), inst.GetRs1(), inst.GetRs2()
				if rd == 0 {
					break
				}
				switch f3 := inst.GetFunct3(); f3 {
				case decoder.RegDiff:
					switch f7 := inst.GetFunct7(); f7 {
					case decoder.Add: // add rd,rs1,rs2: x[rd] = x[rs1] + x[rs2]
						fmt.Fprintf(w, "_ma_regs.x[%d] = %s + %s;\n", rd, generateReadRegExpr(rs1), generateReadRegExpr(rs2))
					case decoder.Sub: // sub rd,rs1,rs2: x[rd] = x[rs1] - x[rs2]
						fmt.Fprintf(w, "_ma_regs.x[%d] = %s - %s;\n", rd, generateReadRegExpr(rs1), generateReadRegExpr(rs2))
					default:
						return fmt.Errorf("unsupported RegReg funct7 %+v (PC=0x%08X, instruction=0x%08X)", f7, pc, inst32)
					}
				case decoder.Sll: // sll rd,rs1,rs2: x[rd] = x[rs1] << x[rs2]
					fmt.Fprintf(w, "_ma_regs.x[%d] = %s << %s;\n", rd, generateReadRegExpr(rs1), generateReadRegExpr(rs2))
				case decoder.Slt: // slt rd,rs1,rs2: x[rd] = x[rs1] <s x[rs2]:
					fmt.Fprintf(w, "_ma_regs.x[%d] = (signed)%s < (signed)%s;\n", rd, generateReadRegExpr(rs1), generateReadRegExpr(rs2))
				case decoder.Sltu: // sltu rd,rs1,rs2: x[rd] = x[rs1] <u x[rs2]:
					fmt.Fprintf(w, "_ma_regs.x[%d] = %s < %s;\n", rd, generateReadRegExpr(rs1), generateReadRegExpr(rs2))
				case decoder.Xor: // xor rd,rs1,rs2: x[rd] = x[rs1] ^ x[rs2]
					fmt.Fprintf(w, "_ma_regs.x[%d] = %s ^ %s;\n", rd, generateReadRegExpr(rs1), generateReadRegExpr(rs2))
				case decoder.RegShift:
					switch f7 := inst.GetFunct7(); f7 {
					case decoder.Srl: // srl rd,rs1,rs2: x[rd] = x[rs1] >>u x[rs2]
						fmt.Fprintf(w, "_ma_regs.x[%d] = ((unsigned)%s >> %s & 0x1f);\n", rd, generateReadRegExpr(rs1), generateReadRegExpr(rs2))
					case decoder.Sra: // sra rd,rs1,rs2: x[rd] = x[rs1] >>s x[rs2]
						fmt.Fprintf(w, "_ma_regs.x[%d] = ((signed)%s >> %s & 0x1f);\n", rd, generateReadRegExpr(rs1), generateReadRegExpr(rs2))
					default:
						return fmt.Errorf("unsupported RegReg funct7 %+v (PC=0x%08X, instruction=0x%08X)", f7, pc, inst32)
					}
				case decoder.Or: // or rd,rs1,rs2: x[rd] = x[rs1] | x[rs2]
					fmt.Fprintf(w, "_ma_regs.x[%d] = %s | %s;\n", rd, generateReadRegExpr(rs1), generateReadRegExpr(rs2))
				case decoder.And: // and rd,rs1,rs2: x[rd] = x[rs1] & x[rs2]
					fmt.Fprintf(w, "_ma_regs.x[%d] = %s & %s;\n", rd, generateReadRegExpr(rs1), generateReadRegExpr(rs2))
				default:
					return fmt.Errorf("unsupported RegReg funct3 %+v (PC=0x%08X, instruction=0x%08X)", f3, pc, inst32)
				}
			case decoder.IntRegImm:
				rd, rs1, imm := inst.GetRd(), inst.GetRs1(), inst.GetImmediate()
				if rd == 0 {
					break
				}
				shamt := imm & 0b11111
				switch f3 := inst.GetFunct3(); f3 {
				case decoder.Addi: // addi rd,rs1,imm: x[rd] = x[rs1] + sext(immediate)
					fmt.Fprintf(w, "_ma_regs.x[%d] = %s + (signed)_MA_SIGN_EXT(%d,12);\n", rd, generateReadRegExpr(rs1), imm)
				case decoder.Slli: // slli rd,rs1,shamt: x[rd] = x[rs1] << shamt
					fmt.Fprintf(w, "_ma_regs.x[%d] = %s << %d;\n", rd, generateReadRegExpr(rs1), shamt)
				case decoder.Sr:
					switch f7 := inst.GetFunct7(); f7 {
					case decoder.Srl: // srli rd,rs1,shamt: x[rd] = x[rs1] >>u shamt // logical shift
						fmt.Fprintf(w, "_ma_regs.x[%d] = ((unsigned)%s >> %d);\n", rd, generateReadRegExpr(rs1), shamt)
					case decoder.Sra: // srai rd,rs1,shamt: x[rd] = x[rs1] >>s shamt // arithmetic shift
						fmt.Fprintf(w, "_ma_regs.x[%d] = ((signed)%s >> %d);\n", rd, generateReadRegExpr(rs1), shamt)
					default:
						return fmt.Errorf("unsupported IntRegImm funct7 %+v (PC=0x%08X, instruction=0x%08X)", f7, pc, inst32)
					}
				case decoder.Slti: // slti rd,rs1,imm: x[rd] = x[rs1] <s sext(immediate)
					fmt.Fprintf(w, "_ma_regs.x[%d] = (signed)%s < (signed)_MA_SIGN_EXT(%d,12);\n", rd, generateReadRegExpr(rs1), imm)
				case decoder.Sltiu: // sltiu rd,rs1,imm: x[rd] = x[rs1] <u sext(immediate)
					fmt.Fprintf(w, "_ma_regs.x[%d] = (unsigned) %s < (unsigned)_MA_SIGN_EXT(%d,12);\n", rd, generateReadRegExpr(rs1), imm)
				case decoder.Andi: // andi rd,rs1,imm: x[rd] = x[rs1] & sext(immediate)
					fmt.Fprintf(w, "_ma_regs.x[%d] = %s & (signed)_MA_SIGN_EXT(%d,12);\n", rd, generateReadRegExpr(rs1), imm)
				case decoder.Xori: // xori rd,rs1,imm: x[rd] = x[rs1] ^ sext(immediate)
					fmt.Fprintf(w, "_ma_regs.x[%d] = %s ^ (signed)_MA_SIGN_EXT(%d,12);\n", rd, generateReadRegExpr(rs1), imm)
				case decoder.Ori: // ori rd,rs1,imm: x[rd] = x[rs1] | sext(immediate)
					fmt.Fprintf(w, "_ma_regs.x[%d] = %s | (signed)_MA_SIGN_EXT(%d,12);\n", rd, generateReadRegExpr(rs1), imm)
				default:
					return fmt.Errorf("unsupported IntRegImm funct3 %+v (PC=0x%08X, instruction=0x%08X)", f3, pc, inst32)
				}
			case decoder.Load:
				rd, rs1, imm := inst.GetRd(), inst.GetRs1(), inst.GetImmediate()
				if rd == 0 {
					break
				}
				fmt.Fprintf(w, "uint8_t *p = _ma_translate_ptr(%s + (signed)_MA_SIGN_EXT(%d,12));\n", generateReadRegExpr(rs1), imm)
				switch f3 := inst.GetFunct3(); f3 {
				case decoder.Lb: // lb rd,offset(rs1): x[rd] = sext(M[x[rs1] + sext(offset)][7:0])
					fmt.Fprintln(w, "uint8_t x;")
					fmt.Fprintln(w, "memcpy(&x, p, 1);")
					fmt.Fprintf(w, "_ma_regs.x[%d] = (signed)_MA_SIGN_EXT((_ma_reg_t)x, 8);\n", rd)
				case decoder.Lbu: // lbu rd,offset(rs1): x[rd] = M[x[rs1] + sext(offset)][7:0]
					fmt.Fprintln(w, "uint8_t x;")
					fmt.Fprintln(w, "memcpy(&x, p, 1);")
					fmt.Fprintf(w, "_ma_regs.x[%d] = x;\n", rd)
				case decoder.Lh: // lh rd,offset(rs1): x[rd] = sext(M[x[rs1] + sext(offset)][15:0])
					fmt.Fprintln(w, "uint16_t x;")
					fmt.Fprintln(w, "memcpy(&x, p, 2);")
					fmt.Fprintf(w, "_ma_regs.x[%d] = (signed)_MA_SIGN_EXT((_ma_reg_t)x, 16);\n", rd)
				case decoder.Lhu: // lhu rd,offset(rs1): x[rd] = M[x[rs1] + sext(offset)][15:0]
					fmt.Fprintln(w, "uint16_t x;")
					fmt.Fprintln(w, "memcpy(&x, p, 2);")
					fmt.Fprintf(w, "_ma_regs.x[%d] = x;\n", rd)
				case decoder.Lw: // lw rd,offset(rs1): x[rd] = sext(M[x[rs1] + sext(offset)][31:0])
					fmt.Fprintln(w, "uint32_t x;")
					fmt.Fprintln(w, "memcpy(&x, p, 4);")
					fmt.Fprintf(w, "_ma_regs.x[%d] = (signed)_MA_SIGN_EXT((_ma_reg_t)x, 32);\n", rd)
				default:
					return fmt.Errorf("unsupported Load funct3 %+v (PC=0x%08X, instruction=0x%08X)", f3, pc, inst32)
				}
			case decoder.Store:
				rs1, rs2, imm := inst.GetRs1(), inst.GetRs2(), inst.GetImmediate()
				fmt.Fprintf(w, "uint8_t *p = _ma_translate_ptr(%s + (signed)_MA_SIGN_EXT(%d,12));\n", generateReadRegExpr(rs1), imm)
				switch f3 := inst.GetFunct3(); f3 {
				case decoder.Sb: // sb rs2,offset(rs1): M[x[rs1] + sext(offset)] = x[rs2][7:0]]
					fmt.Fprintf(w, "uint8_t x = %s & 0xFF;\n", generateReadRegExpr(rs2))
					fmt.Fprintln(w, "memcpy(p, &x, 1);")
				case decoder.Sh: // sh rs2,offset(rs1): M[x[rs1] + sext(offset)] = x[rs2][15:0]]
					fmt.Fprintf(w, "uint16_t x = %s & 0xFFFF;\n", generateReadRegExpr(rs2))
					fmt.Fprintln(w, "memcpy(p, &x, 2);")
				case decoder.Sw: // sw rs2,offset(rs1): M[x[rs1] + sext(offset)] = x[rs2][31:0]]
					fmt.Fprintf(w, "uint32_t x = %s & 0xFFFFFFFF;\n", generateReadRegExpr(rs2))
					fmt.Fprintln(w, "memcpy(p, &x, 4);")
				default:
					return fmt.Errorf("unsupported Store funct3 %+v (PC=0x%08X, instruction=0x%08X)", f3, pc, inst32)
				}
			case decoder.Branch:
				rs1, rs2, imm := inst.GetRs1(), inst.GetRs2(), inst.GetImmediate()
				switch f3 := inst.GetFunct3(); f3 {
				case decoder.Beq: // beq rs1,rs2,offset: if (x[rs1] == x[rs2]) pc += sext(offset)
					fmt.Fprintf(w, "if (%s == %s) { _ma_regs.pc += (signed)_MA_SIGN_EXT(%d,13); continue; }\n", generateReadRegExpr(rs1), generateReadRegExpr(rs2), imm)
				case decoder.Bne: // bne rs1,rs2,offset: if (x[rs1] != x[rs2]) pc += sext(offset)
					fmt.Fprintf(w, "if (%s != %s) { _ma_regs.pc += (signed)_MA_SIGN_EXT(%d,13); continue; }\n", generateReadRegExpr(rs1), generateReadRegExpr(rs2), imm)
				case decoder.Blt: // blt rs1,rs2,offset: if (x[rs1] <s x[rs2]) pc += sext(offset) // signed
					fmt.Fprintf(w, "if ((signed)%s < (signed)%s) { _ma_regs.pc += (signed)_MA_SIGN_EXT(%d,13); continue; }\n", generateReadRegExpr(rs1), generateReadRegExpr(rs2), imm)
				case decoder.Bltu: // bltu rs1,rs2,offset: if (x[rs1] <u x[rs2]) pc += sext(offset) // unsigned
					fmt.Fprintf(w, "if (%s < %s) { _ma_regs.pc += (signed)_MA_SIGN_EXT(%d,13); continue; }\n", generateReadRegExpr(rs1), generateReadRegExpr(rs2), imm)
				case decoder.Bge: // bge rs1,rs2,offset: if (x[rs1] >=s x[rs2]) pc += sext(offset) // signed
					fmt.Fprintf(w, "if ((signed)%s >= (signed)%s) { _ma_regs.pc += (signed)_MA_SIGN_EXT(%d,13); continue; }\n", generateReadRegExpr(rs1), generateReadRegExpr(rs2), imm)
				case decoder.Bgeu: // bgeu rs1,rs2,offset: if (x[rs1] >=u x[rs2]) pc += sext(offset) // unsigned
					fmt.Fprintf(w, "if (%s >= %s) { _ma_regs.pc += (signed)_MA_SIGN_EXT(%d,13); continue; }\n", generateReadRegExpr(rs1), generateReadRegExpr(rs2), imm)
				default:
					return fmt.Errorf("unsupported Branch funct3 %+v (PC=0x%08X, instruction=0x%08X)", f3, pc, inst32)
				}
			case decoder.Lui: // lui rd,imm: x[rd] = sext(immediate[31:12] << 12)
				rd, imm := inst.GetRd(), inst.GetImmediate()
				if rd == 0 {
					break
				}
				fmt.Fprintf(w, "_ma_regs.x[%d] = (signed)_MA_SIGN_EXT(%d,32);\n", rd, imm)
			case decoder.Auipc: // auipc rd,imm: x[rd] = pc + sext(immediate[31:12] << 12)
				rd, imm := inst.GetRd(), inst.GetImmediate()
				if rd == 0 {
					break
				}
				fmt.Fprintf(w, "_ma_regs.x[%d] = %d + (signed)_MA_SIGN_EXT(%d,32);\n", rd, pc, imm)
			case decoder.Jal: // jal rd,offset: x[rd] = pc+4; pc += sext(offset)
				rd, imm := inst.GetRd(), inst.GetImmediate()
				if rd != 0 {
					fmt.Fprintf(w, "_ma_regs.x[%d] = %d + 4;\n", rd, pc)
				}
				fmt.Fprintf(w, "_ma_regs.pc += (signed)_MA_SIGN_EXT(%d,21);\n", imm)
				fmt.Fprintln(w, "continue; /* PC was modified */")
			case decoder.Jalr: // jalr rd,rs1,offset: t =pc+4; pc=(x[rs1]+sext(offset))&∼1; x[rd]=t
				rd, rs1, imm := inst.GetRd(), inst.GetRs1(), inst.GetImmediate()
				if rd != 0 {
					fmt.Fprintf(w, "_ma_reg_t t_val = %d +4;\n", pc)
				}
				fmt.Fprintf(w, "_ma_regs.pc = (%s + (signed)_MA_SIGN_EXT(%d,12))&~1;\n", generateReadRegExpr(rs1), imm)
				if rd != 0 {
					fmt.Fprintf(w, "_ma_regs.x[%d] = t_val;\n", rd)
				}
				fmt.Fprintln(w, "continue; /* PC was modified */")
			case decoder.Sys:
				fmt.Fprintln(w, "_ma_ecall();")
			case decoder.FenceOp: // WIP, probably wrong
				fmt.Fprintln(w, "/* NOP */;")
			case decoder.Atomic:
				f5head, f5tail := decoder.Funct5Head(inst32>>29), decoder.Funct5Tail((inst32>>27)&0x3)
				switch f3 := inst.GetFunct3(); f3 {
				case decoder.Atomic32: // WIP, probably wrong
					switch f5head {
					case decoder.CommonAtomic:
						switch f5tail {
						case decoder.ArithAtomic: // amoadd.w rd,rs2,(rs1): x[rd] = AMO32(M[x[rs1]] + x[rs2])
							rd, rs1, rs2 := inst.GetRd(), inst.GetRs1(), inst.GetRs2()
							if rd == 0 {
								break
							}
							fmt.Fprintf(w, "_ma_reg_t m_val = *(_ma_reg_t*)_ma_translate_ptr(%s);\n", generateReadRegExpr(rs1))
							fmt.Fprintf(w, "_ma_regs.x[%d] = m_val + %s\n;", rd, generateReadRegExpr(rs2))
						case decoder.Amoswap: // amoswap.w rd,rs2,(rs1): x[rd] = AMO32(M[x[rs1]] SWAP x[rs2])
							rd, rs1, rs2 := inst.GetRd(), inst.GetRs1(), inst.GetRs2()
							fmt.Fprintf(w, "_ma_reg_t m_val = *(_ma_reg_t*)_ma_translate_ptr(%s);\n", generateReadRegExpr(rs1))
							if rd != 0 {
								fmt.Fprintf(w, "_ma_regs.x[%d] = m_val;\n", rd)
							}
							fmt.Fprintf(w, "*(_ma_reg_t*)_ma_translate_ptr(%s) = %s;\n", generateReadRegExpr(rs1), generateReadRegExpr(rs2))
						case decoder.Lr: // lr.w rd,rs1: x[rd] = LoadReserved32(M[x[rs1]])
							rd, rs1 := inst.GetRd(), inst.GetRs1()
							if rd == 0 {
								break
							}
							fmt.Fprintf(w, "_ma_regs.x[%d] = *(_ma_reg_t*)_ma_translate_ptr(%s);\n", rd, generateReadRegExpr(rs1))
						case decoder.Sc: // sc.w rd,rs1,rs2: x[rd] = StoreConditional32(M[x[rs1]], x[rs2])
							rd, rs1, rs2 := inst.GetRd(), inst.GetRs1(), inst.GetRs2()
							fmt.Fprintf(w, "*(_ma_reg_t*)_ma_translate_ptr(%s) = %s;\n", generateReadRegExpr(rs1), generateReadRegExpr(rs2))
							if rd != 0 {
								fmt.Fprintf(w, "_ma_regs.x[%d] = 0;\n", rd)
							}
						default:
							return fmt.Errorf("unsupported Atomic32 CommonAtomic funct5tail %+v (PC=0x%08X, instruction=0x%08X)", f5tail, pc, inst32)
						}
					case decoder.Amoor: // amoor.w rd,rs2,(rs1): x[rd] = AMO32(M[x[rs1]] | x[rs2])
						rd, rs1, rs2 := inst.GetRd(), inst.GetRs1(), inst.GetRs2()
						fmt.Fprintf(w, "_ma_reg_t m_val = *(_ma_reg_t*)_ma_translate_ptr(%s);\n", generateReadRegExpr(rs1))
						if rd != 0 {
							fmt.Fprintf(w, "_ma_regs.x[%d] = m_val;\n", rd)
						}
						fmt.Fprintf(w, "*(_ma_reg_t*)_ma_translate_ptr(%s) = m_val | %s;\n", generateReadRegExpr(rs1), generateReadRegExpr(rs2))
					case decoder.Amomaxu: // amomaxu.w rd,rs2,(rs1): x[rd] = AMO32(M[x[rs1]] MAXU x[rs2])
						rd, rs1, rs2 := inst.GetRd(), inst.GetRs1(), inst.GetRs2()
						fmt.Fprintf(w, "_ma_reg_t m_val = *(_ma_reg_t*)_ma_translate_ptr(%s);\n", generateReadRegExpr(rs1))
						if rd != 0 {
							fmt.Fprintf(w, "_ma_regs.x[%d] = m_val;\n", rd)
						}
						fmt.Fprintf(w, "*(_ma_reg_t*)_ma_translate_ptr(%s) = MAX(m_val, %s);\n", generateReadRegExpr(rs1), generateReadRegExpr(rs2))
					default:
						return fmt.Errorf("unsupported Atomic32 funct5head %+v (PC=0x%08X, instruction=0x%08X)", f5head, pc, inst32)
					}
				default:
					return fmt.Errorf("unsupported Atomic funct3 %+v (PC=0x%08X, instruction=0x%08X)", f3, pc, inst32)
				}
			default:
				return fmt.Errorf("unsupported minor opcode 0x%02X (PC=0x%08X, instruction=0x%08X)", minorOp, pc, inst32)
			}
		default:
			return fmt.Errorf("unsupported major opcode 0x%02X (PC=0x%08X, instruction=0x%08X)", inst.MajOp, pc, inst32)
		}
		fmt.Fprintln(w, "break;}")
		pc += 4
		if pc >= int(textSec.Addr+textSec.Size) {
			break
		}
	}
	fmt.Fprintln(w, "default:")
	w.Write([]byte("_MA_FATALF(\"Invalid PC 0x%08X\", _ma_regs.pc);\n")) // To silence `go vet`
	fmt.Fprintln(w, "break;")
	fmt.Fprintln(w, "} /* switch (_ma_regs.pc) */")
	fmt.Fprintln(w, "_ma_regs.pc += 4;")
	fmt.Fprintln(w, "} /* for */")
	fmt.Fprintln(w, "} /* main */")
	fmt.Fprintln(w, "")

	return nil
}

func generateReadRegExpr(reg decoder.RegisterIndex) string {
	if reg == 0 {
		// Hard-wired zero
		return "0"
	}
	return fmt.Sprintf("_ma_regs.x[%d]", reg)
}
