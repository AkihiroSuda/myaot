package compile

import (
	"bytes"
	"debug/elf"
	_ "embed"
	"encoding/binary"
	"errors"
	"fmt"
	"io"

	"github.com/AkihiroSuda/myaot/pkg/iomisc"
	"github.com/sirupsen/logrus"
	"gitlab.com/knipegp/vemu/decoder"
)

//go:embed rt_c
var rtC []byte

func Compile(w io.Writer, r io.ReaderAt) error {
	w = iomisc.ForceWriter(w) // For code readability

	f, err := elf.NewFile(r)
	if err != nil {
		return err
	}
	defer f.Close()

	logrus.Debugf("ELF: %+v", f.FileHeader)
	if f.ByteOrder != binary.LittleEndian {
		return fmt.Errorf("expected ByteOrder=LittleEndian, got %v", f.ByteOrder)
	}
	if f.Type != elf.ET_EXEC {
		return fmt.Errorf("expected Type=ET_EXEC, got %v", f.Type)
	}
	if f.Machine != elf.EM_RISCV {
		return fmt.Errorf("expected Machine=EM_RISCV, got %v", f.Machine)
	}

	var textSec *elf.Section
	for i, sec := range f.Sections {
		i, sec := i, sec
		logrus.Debugf("ELF: Section %d: %+v", i, sec.SectionHeader)
		switch sec.SectionHeader.Type {
		case elf.SHT_PROGBITS:
			switch sec.Name {
			case ".text":
				if textSec != nil {
					return errors.New("multiple .text sections were found")
				}
				textSec = sec
			}
		}
	}

	if textSec == nil {
		return errors.New("loader: no .text section was found")
	}
	logrus.Debugf("ELF: Text size=%d, begins at 0x%08X", textSec.Size, textSec.Addr)

	// Set constants
	fmt.Fprintln(w, "/* Generated by MyAOT */")
	if logrus.GetLevel() >= logrus.DebugLevel {
		fmt.Fprintln(w, "#define _MA_DEBUG")
	}
	switch f.Class {
	case elf.ELFCLASS32:
		fmt.Fprintln(w, "#define _MA_REG_TYPE uint32_t")
	case elf.ELFCLASS64:
		logrus.Warn("ELFCLASS64 is not properly supported yet")
		fmt.Fprintln(w, "#define _MA_REG_TYPE uint64_t")
	default:
		return fmt.Errorf("unknown ELF class %v", f.Class)
	}
	fmt.Fprintln(w, "")

	// Copy rt_c
	io.Copy(w, bytes.NewReader(rtC))
	fmt.Fprintln(w, "")

	// Generate VMA entries
	vmaEntryIdx := 0
	for _, sec := range f.Sections {
		if sec.Addr == 0 {
			continue
		}
		fmt.Fprintf(w, "/* %+v */\n", sec.SectionHeader)
		fmt.Fprintf(w, "struct _ma_vma_entry _ma_vma_entry_%d = {\n", vmaEntryIdx)
		fmt.Fprintf(w, ".addr = %d,\n", sec.Addr)
		fmt.Fprintf(w, ".len = %d,\n", sec.Size)
		switch {
		case sec.Name == ".text", sec.Type == elf.SHT_NOBITS:
			fmt.Fprintln(w, ".bytes_len = 0,")
			fmt.Fprintln(w, ".bytes = {},")
		default:
			dat, err := sec.Data()
			if err != nil {
				return err
			}
			fmt.Fprintf(w, ".bytes_len = %d,\n", len(dat))
			fmt.Fprintln(w, ".bytes = {")
			for i, b := range dat {
				fmt.Fprintf(w, "0x%02X, ", b)
				if i%16 == 15 {
					fmt.Fprintln(w, "")
				}
			}
			fmt.Fprintln(w, "")
			fmt.Fprintln(w, "}, /* .bytes */ ")
		}
		fmt.Fprintf(w, "}; /* _ma_vma_entry_%d */\n", vmaEntryIdx)
		fmt.Fprintln(w, "")
		vmaEntryIdx++
	}
	fmt.Fprintln(w, "")
	fmt.Fprintln(w, "struct _ma_vma_entry *_ma_vma_entries[] = {")
	for i := 0; i < vmaEntryIdx; i++ {
		fmt.Fprintf(w, "&_ma_vma_entry_%d,\n", i)
	}
	fmt.Fprintln(w, "NULL,")
	fmt.Fprintln(w, "}; /* _ma_vma_entries */")
	fmt.Fprintln(w, "")

	// Generate the main state machine
	if err = generateMain(w, f, textSec); err != nil {
		return err
	}

	return nil
}

func generateMain(w io.Writer, elfFile *elf.File, textSec *elf.Section) error {
	fmt.Fprintln(w, "int main(int argc, char *argv[]) {")
	pc := int(elfFile.Entry)
	fmt.Fprintf(w, "_ma_regs.pc = 0x%08X;\n", pc)
	fmt.Fprintln(w, "for (;;) {")
	w.Write([]byte("_MA_DEBUGF(\"PC 0x%08X\", _ma_regs.pc);\n")) // To silence `go vet`
	fmt.Fprintln(w, "/* TODO: use an explicit jump table (for non-WASM?) */")
	fmt.Fprintln(w, "switch(_ma_regs.pc) {")
	textReader := textSec.Open()
	if _, err := textReader.Seek(int64(elfFile.Entry-textSec.Addr), io.SeekStart); err != nil {
		return fmt.Errorf("failed to jump to the entry address 0x%08X", elfFile.Entry)
	}
	var inst32 uint32
	for {
		// TODO: support non-32 bit instructions
		if err := binary.Read(textReader, binary.LittleEndian, &inst32); err != nil {
			return err
		}
		fmt.Fprintf(w, "case 0x%08X: /* inst = %08X */ \n", pc, inst32)
		inst := decoder.NewRawInstruction(inst32)
		switch inst.MajOp {
		case decoder.Std:
			switch minorOp := inst.GetMinorOpcode(); minorOp {
			case decoder.IntRegImm:
				switch f3 := inst.GetFunct3(); f3 {
				case decoder.Addi: // addi rd,rs1,imm: x[rd] = x[rs1] + sext(immediate)
					rd, rs1, imm := inst.GetRd(), inst.GetRs1(), inst.GetImmediate()
					fmt.Fprintf(w, "_ma_regs.x[%d] = %s + %d;\n", rd, generateReadRegExpr(rs1), imm)
				default:
					return fmt.Errorf("unsupported funct3 %+v (PC=0x%08X, instruction=0x%08X)", f3, pc, inst32)
				}
			case decoder.Auipc: // auipc rd,imm: x[rd] = pc + sext(immediate[31:12] << 12)]
				rd, imm := inst.GetRd(), inst.GetImmediate()
				fmt.Fprintf(w, "_ma_regs.x[%d] = %d + %d;\n", rd, pc, imm&0xFFFFF000)
			case decoder.Sys:
				fmt.Fprintln(w, "_ma_ecall();")
			default:
				return fmt.Errorf("unsupported minor opcode %+v (PC=0x%08X, instruction=0x%08X)", minorOp, pc, inst32)
			}
		default:
			return fmt.Errorf("unsupported major opcode %+v (PC=0x%08X, instruction=0x%08X)", inst.MajOp, pc, inst32)
		}
		fmt.Fprintln(w, "break;")
		pc += 4
		if pc >= int(textSec.Addr+textSec.Size) {
			break
		}
	}
	fmt.Fprintln(w, "default:")
	w.Write([]byte("_MA_FATALF(\"Invalid PC 0x%08X\", _ma_regs.pc);\n")) // To silence `go vet`
	fmt.Fprintln(w, "break;")
	fmt.Fprintln(w, "} /* switch (_ma_regs.pc) */")
	fmt.Fprintln(w, "_ma_regs.pc += 4;")
	fmt.Fprintln(w, "} /* for */")
	fmt.Fprintln(w, "} /* main */")
	fmt.Fprintln(w, "")

	return nil
}

func generateReadRegExpr(reg decoder.RegisterIndex) string {
	if reg == 0 {
		// Hard-wired zero
		return "0"
	}
	return fmt.Sprintf("_ma_regs.x[%d]", reg)
}
